package NewLanguage.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int BE_Assign = 0;
  public static final int BE_Compute = 1;
  public static final int BE_Divide = 2;
  public static final int BE_DivideAssign = 3;
  public static final int BE_EqualTo = 4;
  public static final int BE_GreaterThan = 5;
  public static final int BE_LessThan = 6;
  public static final int BE_Minus = 7;
  public static final int BE_MinusAssign = 8;
  public static final int BE_ModifyAssign = 9;
  public static final int BE_Multiply = 10;
  public static final int BE_MultiplyAssign = 11;
  public static final int BE_Plus = 12;
  public static final int BE_PlusAssign = 13;
  public static final int BiExpression = 14;
  public static final int BoolType = 15;
  public static final int BooleanLiteral = 16;
  public static final int BreakStatement = 17;
  public static final int CatchParameter = 18;
  public static final int CatchStatement = 19;
  public static final int ClosureLiteral = 20;
  public static final int Comment = 21;
  public static final int ContinueStatement = 22;
  public static final int DataType = 23;
  public static final int DecrementAfter = 24;
  public static final int DecrementBefore = 25;
  public static final int Document = 26;
  public static final int DotExpression = 27;
  public static final int DoubleLiteral = 28;
  public static final int DoubleType = 29;
  public static final int Else = 30;
  public static final int ElseIf = 31;
  public static final int ElseStatement = 32;
  public static final int Expression = 33;
  public static final int ExpressionStatement = 34;
  public static final int Field = 35;
  public static final int FieldAccessor = 36;
  public static final int FinallyStatement = 37;
  public static final int ForLoop = 38;
  public static final int Function = 39;
  public static final int FunctionCall = 40;
  public static final int FunctionReference = 41;
  public static final int FunctionType = 42;
  public static final int ICallable = 43;
  public static final int ICanBeLabelled = 44;
  public static final int IDotOperation = 45;
  public static final int IHasCondition = 46;
  public static final int IHasMethods = 47;
  public static final int IVariable = 48;
  public static final int IfStatement = 49;
  public static final int IncrementAfter = 50;
  public static final int IncrementBefore = 51;
  public static final int IntType = 52;
  public static final int IntegerLiteral = 53;
  public static final int LExpression = 54;
  public static final int Label = 55;
  public static final int ListLiteral = 56;
  public static final int ListType = 57;
  public static final int MapLiteral = 58;
  public static final int MapType = 59;
  public static final int MethodAccessor = 60;
  public static final int MethodDeclaration = 61;
  public static final int MethodImplementation = 62;
  public static final int NestedBlock = 63;
  public static final int NumType = 64;
  public static final int Pair = 65;
  public static final int Parameter = 66;
  public static final int PrintStatement = 67;
  public static final int ReturnStatement = 68;
  public static final int Statement = 69;
  public static final int StatementBlock = 70;
  public static final int StringLiteral = 71;
  public static final int StringType = 72;
  public static final int StructDeclaration = 73;
  public static final int StructLiteral = 74;
  public static final int StructType = 75;
  public static final int Ternary = 76;
  public static final int ThisVar = 77;
  public static final int ThrowStatement = 78;
  public static final int TraitDeclaration = 79;
  public static final int TraitReference = 80;
  public static final int TraitType = 81;
  public static final int TryStatement = 82;
  public static final int TypeCast = 83;
  public static final int UnaryOperator = 84;
  public static final int ValueAccess = 85;
  public static final int VarReference = 86;
  public static final int VariableDeclaration = 87;
  public static final int WhileLoop = 88;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x80fd2975f5c34fe6L, 0xa787f3eac6fef3beL);
    builder.put(0x2e5495258f852fbL, BE_Assign);
    builder.put(0x2e5495258f85334L, BE_Compute);
    builder.put(0x2170c94162fc8ebdL, BE_Divide);
    builder.put(0x2170c94162fc8ebfL, BE_DivideAssign);
    builder.put(0x2f07de646556e14aL, BE_EqualTo);
    builder.put(0x2f07de646556d9b9L, BE_GreaterThan);
    builder.put(0x2f07de646554f88fL, BE_LessThan);
    builder.put(0x2e5495258b72e22L, BE_Minus);
    builder.put(0x2170c94162fc8ec0L, BE_MinusAssign);
    builder.put(0x2e5495258f852fcL, BE_ModifyAssign);
    builder.put(0x2170c94162fc8ebcL, BE_Multiply);
    builder.put(0x2170c94162fc8ebeL, BE_MultiplyAssign);
    builder.put(0x2f07de6465531231L, BE_Plus);
    builder.put(0x2e5495258ded016L, BE_PlusAssign);
    builder.put(0x2f07de6465546b24L, BiExpression);
    builder.put(0x2e549525875652aL, BoolType);
    builder.put(0x2e549525875652bL, BooleanLiteral);
    builder.put(0x2e54952583e6167L, BreakStatement);
    builder.put(0x2bfa9913b4214a21L, CatchParameter);
    builder.put(0x2bfa9913b41b25e3L, CatchStatement);
    builder.put(0x2e54952596b49a3L, ClosureLiteral);
    builder.put(0x69a8a294c1a68b3bL, Comment);
    builder.put(0x2e54952583e7ffeL, ContinueStatement);
    builder.put(0x2e5495258561dbeL, DataType);
    builder.put(0x2e54952595afaf5L, DecrementAfter);
    builder.put(0x2e54952595afaf6L, DecrementBefore);
    builder.put(0x580a917d12c3a82aL, Document);
    builder.put(0x2170c94162546b6dL, DotExpression);
    builder.put(0x39c216b1a43c987fL, DoubleLiteral);
    builder.put(0x39c216b1a430a0a3L, DoubleType);
    builder.put(0x2170c941630b5732L, Else);
    builder.put(0x2170c941630b672cL, ElseIf);
    builder.put(0x2170c941630b571fL, ElseStatement);
    builder.put(0x2f07de6465204d70L, Expression);
    builder.put(0x2f07de64655f40f2L, ExpressionStatement);
    builder.put(0x2170c9416258b6a5L, Field);
    builder.put(0x2170c94162589199L, FieldAccessor);
    builder.put(0x2bfa9913b41b25e5L, FinallyStatement);
    builder.put(0x2170c94163021162L, ForLoop);
    builder.put(0x2f07de6465348273L, Function);
    builder.put(0x2f07de6465374cacL, FunctionCall);
    builder.put(0x62ec3338d1ae9d8eL, FunctionReference);
    builder.put(0x2170c941610e62d9L, FunctionType);
    builder.put(0x2e54952596b4e3eL, ICallable);
    builder.put(0x2bfa9913b36c66cbL, ICanBeLabelled);
    builder.put(0x2170c94162546b6cL, IDotOperation);
    builder.put(0x69a8a294bd8f8a38L, IHasCondition);
    builder.put(0x69a8a294bec93234L, IHasMethods);
    builder.put(0x2f07de64655210d1L, IVariable);
    builder.put(0x2f07de646545f01eL, IfStatement);
    builder.put(0x2e54952595afaf3L, IncrementAfter);
    builder.put(0x2e54952595afaf4L, IncrementBefore);
    builder.put(0x2e5495258561dc8L, IntType);
    builder.put(0x580a917d12c5d77dL, IntegerLiteral);
    builder.put(0x69a8a294c049151cL, LExpression);
    builder.put(0x2bfa9913b363e772L, Label);
    builder.put(0x2e54952594c811cL, ListLiteral);
    builder.put(0x2e549525877d7d7L, ListType);
    builder.put(0x69a8a294bee50a63L, MapLiteral);
    builder.put(0x69a8a294bee50a20L, MapType);
    builder.put(0x2bfa9913b40d8fd9L, MethodAccessor);
    builder.put(0x69a8a294bce40a80L, MethodDeclaration);
    builder.put(0x69a8a294bce41cf9L, MethodImplementation);
    builder.put(0x2bfa9913b38b9de4L, NestedBlock);
    builder.put(0x69a8a294c01651b0L, NumType);
    builder.put(0x69a8a294beee9c2cL, Pair);
    builder.put(0x2f07de6465348282L, Parameter);
    builder.put(0x2e5495258470741L, PrintStatement);
    builder.put(0x2f07de64654b9c43L, ReturnStatement);
    builder.put(0x2f07de64652e4561L, Statement);
    builder.put(0x2f07de64652e4562L, StatementBlock);
    builder.put(0x2e54952585666a8L, StringLiteral);
    builder.put(0x2e5495258565786L, StringType);
    builder.put(0x2170c9416229bf84L, StructDeclaration);
    builder.put(0x2170c94162388944L, StructLiteral);
    builder.put(0x2170c9416229bf81L, StructType);
    builder.put(0x2f07de6465587e79L, Ternary);
    builder.put(0x69a8a294bdda8581L, ThisVar);
    builder.put(0x2bfa9913b423c5ceL, ThrowStatement);
    builder.put(0x2bfa9913b4017060L, TraitDeclaration);
    builder.put(0x69a8a294bd25a4f8L, TraitReference);
    builder.put(0x2bfa9913b466bfedL, TraitType);
    builder.put(0x2bfa9913b41b23e5L, TryStatement);
    builder.put(0x39c216b1a473fd97L, TypeCast);
    builder.put(0x2e54952595afaf2L, UnaryOperator);
    builder.put(0x69a8a294bef04926L, ValueAccess);
    builder.put(0x2f07de64652aa793L, VarReference);
    builder.put(0x580a917d12c273afL, VariableDeclaration);
    builder.put(0x2f07de6465610090L, WhileLoop);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
